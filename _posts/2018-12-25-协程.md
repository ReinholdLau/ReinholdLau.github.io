---
title: 协程
categories:
  - 计算机
tags:
  - 计算机
---

#### 并发与并行简介

**并行（parallel):**指在同一时刻，有多条指令在多个处理器上同时执行。

**并发（concurrency):**指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。

 并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。 



#### 协程(Coroutine)

Coroutine是一种用户态的轻量级线程，特点如下：

- 轻量级线程

- 非抢占式多任务处理，由协程主动交出控制权

- 编译器、解释器、虚拟机层面的任务

- 多个协程可能在一个或多个线程上运行

- 子程序是协程的一个特例

  不同语言对协程的支持：

  - C++通过Boost.Coroutine实现对协程的支持
  - Java不支持
  - Python通过yield关键字实现协程，Python3.5开始使用async def对原生协程的支持

协程，也有人称之为轻量级线程，具备以下几个特点：

- 能够在单一的系统线程中模拟多个任务的并发执行。
- 在一个特定的时间，只有一个任务在运行，既并非真正地并行。
- 被动的任务调度方式，即任务没有主动抢占时间片的说法。当一个任务正在执行时，外部没有办法终止它。要进行任务切换，智能通过由该任务自身调用**yield()**来主动让出CPU使用权。
- 每个协程都有自己的堆栈和局部变量。

每个协程都包含3种运行状态：挂起、运行和停止。停止通常表示该协程已经执行完成（包括遇到问题后明确退出执行的情况），挂起则表示该协程尚未执行完成，但让出了时间片，以后有机会时会有调度器继续执行。





#### Go调度器简介（Go scheduler)

**Go的最小调度单元为goroutine，但操作系统最小的调度单元依然是线程，所以go调度器（go scheduler）要做的工作是如何将众多的goroutine放在有限的线程上进行高效而公平的调度。** 操作系统的调度不失为高效和公平，比如CFS调度算法。go引入goroutine的核心原因是goroutine轻量级，无论是从进程到线程，还是从线程到goroutine，其核心都是为了使调度单元更加轻量级，可以轻易创建几万几十万的goroutine而不用担心内存耗尽等问题。go引入goroutine试图在语言内核层做到足够高性能得同时（充分利用多核优势、使用epoll高效处理网络／IO、实现垃圾回收等机制）尽量简化编程。 